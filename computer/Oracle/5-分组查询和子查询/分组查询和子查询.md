# 分组查询和子查询

## 一、分组查询

在Oracle中，使用关键字GROUP BY子句来将表中数据分成若干小组进行操作。

```sql
-- 统计每个部门的总工资, 总人数和平均工资
SELECT deptno,SUM(sal),COUNT(*),AVG(sal) FROM emp GROUP BY deptno ORDER BY deptno;
-- 统计每个部门的总工资, 总人数和平均工资, 排除10部门的信息
SELECT deptno,SUM(sal),COUNT(*),AVG(sal) FROM emp WHERE deptno<>10 GROUP BY deptno ORDER BY deptno;
```

注意：WHERE子句要写在GROUP BY之前，WHERE子句在分组前进行过滤，所以不能对分组后的结果不能过滤，此时需要用HAVING子句。

```sql
-- 统计每个部门的总工资, 总人数和平均工资, 排除平均工资小于2000的部门信息
SELECT deptno,SUM(sal),COUNT(*),AVG(sal) FROM emp GROUP BY deptno HAVING AVG(sal)>=2000 ORDER BY deptno;
-- 统计每个部门的总工资, 总人数和平均工资, 排除平均工资小于2000 的部门信息,排除10部门的信息
SELECT deptno,SUM(sal),COUNT(*),AVG(sal) FROM emp WHERE deptno<>10 GROUP BY deptno HAVING AVG(sal)>=2000 ORDER BY deptno;
-- 下面的语句有错
SELECT deptno,SUM(sal) sum_sal,COUNT(*) cnt,AVG(sal) avg_sal FROM emp GROUP BY deptno HAVING avg_sal>=2000 ORDER BY deptno;
-- 在emp表中，列出工资最小值小于2000的职位
SELECT job,MIN(sal) FROM emp GROUP BY job HAVING MIN(sal)<2000;
-- 列出平均工资大于1200 元的部门和工作搭配组合
SELECT deptno,job,AVG(sal) FROM emp GROUP BY deptno, job HAVING AVG(sal)>1200;
Select  deptno,count(),avg(sal) from emp group by deptno having count()<4 order by deptno;
```

说明：WHERE子句在分组前进行过滤 , HAVING子句在分组后进行过滤，所以在where子句中不能使用分组函数，HAVING中不能使用别名。因为SQL语句执行的顺序如下：

![image](0002.png)

## 二、子查询

在很多情况下，需要对查询后的结果再次进行查询，或者一次查询已经不能满足需求，这时就可以用到子查询，子查询会在主查询前执行。

```sql
-- 如何查得所有比“CLARK”工资高的员工的信息
-- 先找到“CLARK”的工资
SELECT sal FROM emp WHERE ename='CLARK';
-- 再查询比“CLARK”工资高的员工
SELECT * FROM emp WHERE sal>2450;
SELECT * FROM emp WHERE sal>(SELECT sal FROM emp WHERE ename='CLARK');
```

说明：如果我们不用子查询完成上面操作，需要分两步完成，没有使用子查询来的简单。

```sql
-- 查询工资高于平均工资的雇员名字和工资。
SELECT ename,sal FROM emp WHERE sal>(SELECT AVG(sal) FROM emp);
-- 查询和SCOTT同一部门且比他工资低的雇员名字和工资
SELECT ename,sal FROM emp WHERE deptno=(SELECT deptno FROM emp WHERE ename='SCOTT') AND sal<(SELECT sal FROM emp WHERE ename='SCOTT');
```

说明：

- 子查询是基于未知值时应考虑使用子查询。
- 子查询必须包含在括号内。
- 建议将子查询放在比较运算符的右侧，以增强可读性。
- 除非进行Top-N分析，否则不要在子查询中使用ORDER BY子句。
- 如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符。
- 如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符。

**1. 单行子查询**

```sql
-- 查询工资最高的雇员名字和工资
SELECT ename, sal FROM emp WHERE sal=(SELECT MAX(sal) FROM emp);
```

**2. 多行子查询**

多行子查询只能使用多行记录比较运算符:

- ALL和子查询返回的所有值比较
- ANY和子查询返回的任意一个值比较
- IN等于列表中的任何一个

```sql
-- 查询工资低于“CLERK”的最高工资的雇员信息。
SELECT * FROM emp WHERE sal<(SELECT MAX(sal) FROM emp WHERE job='CLERK');
SELECT * FROM emp WHERE sal<ANY(SELECT sal FROM emp WHERE job='CLERK');
-- 查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。
SELECT empno,ename, sal FROM emp WHERE sal>ALL(SELECT sal FROM emp WHERE job='SALESMAN');
-- 查询部门20中职务同部门10的雇员一样的雇员信息。
SELECT job FROM emp WHERE deptno=20;
SELECT job FROM emp WHERE deptno=10;
SELECT * FROM emp WHERE deptno=20 AND job IN (SELECT job FROM emp WHERE deptno=10);
-- 查询在雇员中有哪些人是领导
SELECT * FROM emp WHERE empno IN (SELECT DISTINCT mgr FROM emp WHERE mgr IS NOT NULL);
-- 找出部门编号为20的所有员工中收入最高的职员
SELECT * FROM emp WHERE deptno=20 AND sal>=ALL(SELECT sal FROM emp WHERE deptno=20);
```

子查询可以出现在from子句中, 表示一张表(临时表)，这里用到的多表查询后面会讲到。

```sql
-- 查询每个部门平均薪水的等级
SELECT deptno, AVG(sal) FROM emp GROUP BY deptno;
SELECT t.deptno, t.avg_sal, s.grade
FROM salgrade s, (
	SELECT deptno, AVG(sal) avg_sal FROM emp GROUP BY deptno
) t
WHERE t.avg_sal BETWEEN s.losal AND s.hisal;
```




