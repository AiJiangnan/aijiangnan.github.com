<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <script src="../../../js/markdown.js"></script>
    <script src="../../../js/jquery.min.js"></script>

    <link rel="stylesheet" href="../../../css/content.css">
    <title>面向对象编程</title>
</head>

<body>
    <textarea hidden id="content">
<!--Markdown从这里开始  -->
# 面向对象编程

## 一、类和对象的概念

我们在第一章就讲到了面向对象的发展过程，搞懂了类和对象的概念，理解面向对象编程就很简单了。对类的概念其实很容易理解，我们从小就开始会对很多事物进行分类，而这个分类的过程，就是一个抽象的总结过程，总结出来的结果就是类。例如：我们把红、绿、蓝……叫做颜色，把狗、猫、猪……叫做动物，等等这种分类的例子都是对事物抽象的总结，我们就可以把它们称作颜色类、动物类。当有了类，我们一般处理的是对象，对象就是由类定义出来的具体的事物，比如：我们要使用一个红色，就用颜色类去定义一个红色，因为颜色类已经总结了所有颜色，在这里，红色就是一个对象。只要理解好了类和对象，后面的很多问题就会迎刃而解。

>  对象和类的关系：特殊到一般，具体到抽象。

例如：定义一个学生类，并创建两个学生对象，它有姓名和年龄等特征，我们的需求只考虑姓名和年龄，所以在这里，只要有姓名和年龄的对象，我们都可以当作“学生”。

```java
public class Demo01 {
	public static void main(String[] args) {
		Student s1 = new Student("Alice",18);
		Student s2 = new Student("Bob",20);
		System.out.println(""
				+ "Name: " + s1.name + "\tAge: " + s1.age + "\n"
				+ "Name: " + s2.name + "\tAge: " + s2.age);
	}
	// print:
	//	Name: Alice	Age: 18
	//	Name: Bob	Age: 20
}

class Student{
	String name;
	int age;

	public Student(String name,int age){
		this.name = name;
		this.age = age;
	}
}
```

分析：在Java中用关键字`class`来创建类，使用`new`关键字来创建对象。在对象中定义的变量叫做类的属性（成员变量），比如Student类中的name和age，用点号来调用它们。在类中会定义一个与类名一样并且没有返回值的方法，这个特殊的方法叫做构造方法（构造器），它用于构造该类的实例，定义参数来对类进行初始化。我们用`new`定义的对象赋值的变量s1和s2是引用类型（除基本数据类型之外的数据类型都是引用类型），Java中的对象是通过引用对其操作的。

内存原理图： ![0002](0002.png)

### 内存分析

#### 栈：

- 每个线程私有，不能实现线程间的共享。
- 局部变量放置于栈中。
- 栈是由系统自动分配，速度快的连续的内存空间。

#### 堆：

- 放置new出来的对象。
- 堆是一个不连续的内存空间，分配灵活，速度慢。

#### 方法区：

- 被所有线程共享。
- 用来存放程序中**永远是不变唯一**的内容（类代码信息、静态变量、字符串常量）。

#### 对象的创建和使用

- 必须使用 new 关键字创建对象。

  ​Person person= new Person ();

- 使用对象<u>（引用） . 成员变量</u>来引用对象的成员变量。

  ​person.age

- 使用对象<u>（引用） . 方法（参数列表）</u>来调用对象的方法。

  ​person. setAge(23)

- 同一类的每个对象有不同的成员变量存储空间。


- 同一类的每个对象共享该类的方法。

**实例：**定义一个二维空间内的点的类，实现可以生成具有特定坐标的点对象，提供可以设置二个坐标的方法，提供可以计算该“点”距另外点距离的方法。

```java
public class Point {
	double x;
	double y;

	public Point(double x, double y) {
		this.x = x;
		this.y = y;
	}

	public double getDistance(Point p){
		double dx = this.x - p.x;
		double dy = this.y - p.y;
		return Math.sqrt(dx*dx + dy*dy);
	}
}
```

```java
public class Demo02 {
	public static void main(String[] args) {
		Point p1 = new Point(0, 0);
		Point p2 = new Point(3, 4);
		double d = p1.getDistance(p2);
		System.out.println("p1--p2: " + d);		// print: p1--p2: 5.0
	}
}
```

## 二、面向对象三大特征

### 1. 封装

从名字上看，我们应该就大致了解封装是什么东西了，为什么需要封装？看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗？有必要碰碰显像管吗？制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如：电源开关。具体怎么实现的，我们不需要操心。需要用户知道的暴露出来，不需要用户了解的全部隐藏起来，这就是封装。程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。

####  访问权限修饰符

|             | 同一个类 | 同一个包 |  子类  | 所有类  |
| :---------: | :--: | :--: | :--: | :--: |
|  `private`  |  *   |      |      |      |
|  `default`  |  *   |  *   |      |      |
| `protected` |  *   |  *   |  *   |      |
|  `public`   |  *   |  *   |  *   |  *   |

类的属性一般使用`private`提供相应的get和set方法（`public`）来访问和设置相关属性。注意：`boolean`类型变量的get方法通常是用is开头。一些只用于本类的辅助性方法可以用`private`， 希望其他类调用的方法用`public`。

例如：采用封装定义一个人类，有姓名和年龄属性。

```java
public class Demo03 {
	public static void main(String[] args) {
		People p1 = new People("Alice", 18);
		People p2 = new People("Clork", 23);
		p2.setAge(20);;
		System.out.println(""
				+"Name\tAge\n"
				+p1.getName()+"\t"+p1.getAge()+"\n"
				+p2.getName()+"\t"+p2.getAge());
	}
	// print:
	//	Name	Age
	//	Alice	18
	//	Clork	20
}

class People{
	private String name;
	private int age;

	public People(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
```

#### 方法的重载（overload）

方法的重载是指一个类中可以定义有相同的名字，但参数不同的多个方法。 调用时，会根据不同的参数表选择对应的方法。在调用方法时，会匹配最近的类型。这在定义方法上很灵活。方法的重载中关键是掌握**参数不同**这个点，可以是参数的个数、类型、或者不同类型的顺序不同。方法中别的不同并不能构成重载，比如返回值类型不同。与普通方法一样，构造方法也能构成重载。

例如：我们编写方法实现数的加法，不仅可以进行整数运算，还能进行小数运算。

```java
public class Demo04 {
	public static void main(String[] args) {
		int sum1 = add(1,2,3,4);
		double sum2 = add(1.1,2.2,3.3,4.4);
		System.out.println(sum1);		// print: 10
		System.out.println(sum2);		// print: 11.0
	}

	public static int add(int...a) {
		int sum = 0;
		for(int i=0;i<a.length;i++){
			sum += a[i];
		}
		return sum;
	}

	public static double add(double...a) {
		double sum = 0;
		for(int i=0;i<a.length;i++){
			sum += a[i];
		}
		return sum;
	}
}
```

分析：在这里我们用到可变参数来实现多个数的相加，并且实现方法的重载，编写两个方法来实现整数和小数的加法。在调用方法时，Java会自动根据实参来选择适合的方法。

#### this关键字

在前面我们经常用到了this关键字，却一直没提到它，但是那并不影响我们理解代码，现在就来说说这个关键字。this总是指向当前类或是当前对象。在普通方法中，指向调用该方法的对象，构造方法中，指向正要初始化的对象。

**this常用的用法：**

- 让类中的一个方法，访问该类的另一个方法或属性。
- 调用重载构造方法。避免相同的初始化代码，只能在构造方法中用，并且必须位于构造方法的第一句。

例如：定义一个手机类，具有手机类型和手机的发布时间属性，还有支持2G或支持3G信号的方法。

```java
public class Demo05 {
	public static void main(String[] args) {
		Phone p1 = new Phone("Nokia");
		Phone p2 = new Phone("IPhone", "2016");
		System.out.println("Type: "+p1.getType()+"\tData: "+p1.getDate());
		p1.support2G();
		System.out.println("Type: "+p2.getType()+"\tData: "+p2.getDate());
		p2.support3G();
	}
	// print:
	//	Type: Nokia	Data: null
	//	I can suppoort 2G!
	//	Type: IPhone	Data: 2016
	//	I can suppoort 2G!
	//	I can suppoort 3G!
}

class Phone{
	private String type;
	private String date;

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public String getDate() {
		return date;
	}

	public void setDate(String date) {
		this.date = date;
	}

	public Phone(String type) {
		this.type = type;
	}

	public Phone(String type, String date) {
		this(type);
		this.date = date;
	}

	public void support2G(){
		System.out.println("I can suppoort 2G!");
	}

	public void support3G(){
		this.support2G();
		System.out.println("I can suppoort 3G!");
	}
}
```

分析：我们创建两个品牌的手机Nokia和IPhone，假设已经不知道Nokia手机的发布日期，并且Nokia手机只支持2G信号，而IPhone同时支持2G和3G信号。在set方法中，用this调用了当前对象的属性;在构造方法中，用this调用其他构造方法;在方法中，用this调用了当前对象的其他方法。

#### static关键字

在类中，用static声明的成员变量为静态成员变量。

- 它为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时执行。
- 对于该类的所有对象来说，static成员变量只有一份。
- 可以使用“对象.类属性”来调用，不过，一般都是用“类名.类属性”，不需要实例化。

用static声明的方法为静态方法。

- 不需要对象，就可以调用（类名.方法名）。
- 在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员。

> 静态成员变量属于类，所以又叫类变量，静态方法也叫类方法。

例如：定义一个学生类，具有姓名、学费和总学费属性，总学费为静态变量，并有交学费的方法。

```java
public class Demo06 {
	public static void main(String[] args) {
		Stu s1 = new Stu("Alice", 1200);
		s1.payTuition();
		Stu s2 = new Stu("Bob", 1300);
		s2.payTuition();
		System.out.println("Total: $"+Stu.tuition);
	}
	// print:
	//	Alice pay tuition fee $1200
	//	Bob pay tuition fee $1300
	//	Total: $2500
}

class Stu{
	private String name;
	private int tuit;
	public static int tuition;

	public Stu(String name, int tuit) {
		this.name = name;
		this.tuit = tuit;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getTuit() {
		return tuit;
	}

	public void setTuit(int tuit) {
		this.tuit = tuit;
	}

	public void payTuition(){
		tuition += tuit;
		System.out.println(name+" pay tuition fee $"+tuit);
	}
}
```

**静态代码块**

经常用来初始化类，加载类信息时执行。如果希望加载后，对整个类进行某些初始化操作，可以使用static初始化块，它是在类初始化时执行，不是在创建对象时执行。静态代码块中不能访问非static成员。上溯到Object 类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。

例如：使用代码测试静态代码块、普通代码块和构造方法的执行顺序。

```java
public class Demo07 {
	public static void main(String[] args) {
		new Static();
	}
	// print:
	//	I am a static block!
	//	I am a normal block!
	//	I am a constructor!
}

class Static{
	static{
		System.out.println("I am a static block!");
	}

	{
		System.out.println("I am a normal block!");
	}

	public Static() {
		System.out.println("I am a constructor!");
	}
}
```

### 2. 继承

在Java中为什么需要继承？类是对对象的抽象，继承是对某一批类的抽象。为了提高代码的复用性，子类在父类的基础上进行了扩展。比如我们前面常说的人类、学生类、老师类等等，学生和老师都具有人类的属性和方法，这种情况我们就不需要重新在学生和老师的类中定义这些属性和方法了，直接继承人类的属性和方法就行了。这就体现了继承存在的意义了。

例如：我们定义一个动物类，然后定义一个小狗类来继承动物的属性和方法。

```java
public class Demo08 {
	public static void main(String[] args) {
		Dog d = new Dog(2, 'M', "Taidi");
		System.out.println(""
				+"Name:\t"+d.getName()+"\n"
				+"Gender:\t"+d.getGender()+"\n"
				+"Age:\t"+d.getAge());
		d.eat();
		d.bark();
	}
	// print:
	//	Name:	Taidi
	//	Gender:	M
	//	Age:	2
	//	Animal can eat!
	//	Wang Wang Wang!
}

class Animal{
	private int age;
	private char gender;

	public Animal(int age, char gender) {
		this.age = age;
		this.gender = gender;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public char getGender() {
		return gender;
	}

	public void setGender(char gender) {
		this.gender = gender;
	}

	public void eat() {
		System.out.println("Animal can eat!");
	}
}

class Dog extends Animal{
	private String name;

	public Dog(int age, char gender, String name) {
		super(age, gender);
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void bark(){
		System.out.println("Wang Wang Wang!");
	}
}
```

子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)。java 中只有单继承，没有像 c++那样的多继承。java 中的多继承，可以通过接口来实现。如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。父类不同的叫法：超类、基类、子类、派生类。
private 成员问题：子类继承父类的一切东西。子类对象拥有父类对象的完整拷贝。实例化一个类是从最顶级的超类开始实例化的，是一层一层的包裹结构。private限制访问方式只能在类的内部，这仅仅是一个访问控制，实际上子类对象拥有父类对象的一切。

#### 方法的重写

前面已经讲了继承，有时候从父类继承来的方法并不能满足我们的需求，所以在子类中可以根据需要对从父类中继承来的方法进行重写。既然是重写父类的方法，子类中重写的方法与父类中被重写的方法一样，包括方法名称、参数列表和返回值类型。

例如：定义一个猫类，继承前面例子中的动物类，并重写eat()方法。

```java
public class Demo09 {
	public static void main(String[] args) {
		Cat c = new Cat(2, 'W', "XiaoHua");
		c.eat();		// print: Cat eats mouse!
	}
}

class Cat extends Animal{
	private String name;

	public Cat(int age, char gender, String name) {
		super(age, gender);
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public void eat() {
		System.out.println("Cat eats mouse!");
	}
}
```

#### super关键字

前面的例子中，我们提到了super关键字，但没有详细介绍。super和this有点像，不过它是直接父类的引用。可以通过super来访问父类中被子类覆盖的属性或方法。构造函数中：任何类的构造函数中，若是构造函数的第一行代码没有显式的调用super(...);那么 Java 默认都会调用 super();作为父类的初始化函数。所以你这里的 super();加不加都无所谓。

#### final关键字

**修饰变量：**被final修饰的变量不可再赋值。

**修饰方法：**被final修饰的方法不可再重写。

**修饰类：**被final修饰的类不可被继承。

自己理解好这三个情况，问题不大。在修饰变量的情况下，由于不可被赋值，所以认为变量会变成常量，常量的命名方法一般是大写。

### 3. 多态

从名称上理解，就是一个引用可以有多种状态，也就是指向多个对象。地做事之前，不要把话说死，说的范围大一点，真到做的时候再具体化。多态是方法的多态，属性没有多态。多态存在的3个必要条件：<u>继承、方法重写、父类引用指向子类对象</u>。

**引用变量的两种状态类型**

- 编译时类型：比较模糊，一般是一个父类，由声明时的类型决定。
- 运行时类型：运行时，具体是哪个子类就是指哪个子类，由实际对应的对象类型决定。

如果编译时类型和运行时类型不一致，就会造成多态。也就是说，程序的最终状态只有在执行过程中才被决定而不是在编译期间就决定了的。

**方法绑定**

- 静态绑定：在编译期间完成，可以提高代码执行速度。静态绑定的方法包括静态方法、构造方法、private方法、super调用的方法。
- 动态绑定：通过对象调用的方法，采用动态绑定机制。这能让编程灵活，但是降低了代码的执行速度。这也是Java比C/C++速度慢的主要因素之一。

#### 对象的转型

由于引用变量只能调用它编译类型的方法，不能调用它运行类型的方法。这时，我们就需要进行类型的强制转换。

- 一个父类的引用类型变量可以指向其子类的对象。
- 一个父类的引用不可以访问其子类对象新增加的成员。
- 可以使用instanceof关键字来判断该引用指向的对象是否属于某个类。
- 子类的对象可以当作父类的对象来使用称作向上转型，反之为向下转型。

例如：用前面创建的动物类和小猫类完成多态实验。

```java
public class Demo10 {
	public static void main(String[] args) {
		Animal c1 = new Cat(2,'W',"XiaoHong");
		Cat c2 = new Cat(1,'M',"XiaoBai");
		c1.eat();			// print: Cat eats mouse!
		c2.eat();			// print: Cat eats mouse!
		c2 = (Cat)c1;
		System.out.println(c1 instanceof Animal);		// print: true
		System.out.println(c1 instanceof Cat);			// print: true
	}
}
```

## 三、抽象类

抽象类是一种模版模式。抽象类为所有子类提供了一个通用模版，子类可以在这个模版基础上进行扩展。通过抽象类，可以避免子类设计的随意性，严格限制子类的设计。

**抽象类的作用要点**

- 有抽象方法的类只能定义抽象类。
- 抽象类不能实例化，及不能用new来创建对象。
- 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new对象，只能用来被子类调用。
- 抽象类只能用来继承。
- 抽象方法必须被子类实现。

**抽象父类和普通父类的区别**

就在于包含抽象方法，抽象方法必须被子类实现，从而可以对子类的设计进行规范。简单来说就是：<u>实现了规范和具体实现的分离</u>。引用变量仍然可以定义为抽象类，这样就可以规范地实现多态了。

例如：定义交通工具抽象类，再定义一个子类汽车类，并实现两个方法。

```java
public class Demo11 {
	public static void main(String[] args) {
		Transportation car = new Car();
		car.run();			// print: 我能行驶在公路上。
		car.manned();		// print: 我还能载人。
	}
}

abstract class Transportation{
	public abstract void run();
	public abstract void manned();
}

class Car extends Transportation{

	@Override
	public void run() {
		System.out.println("我能行驶在公路上。");
	}

	@Override
	public void manned() {
		System.out.println("我还能载人。");
	}
}
```

## 四、接口

接口就是比抽象类还抽象的抽象类，可以更加规范地对子类进行约束。全面地专业地实现了：<u>规范和具体实现分离</u>。因为抽象类还提供某些具体实现，而接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。

定义接口和定义类的方法一样，只是将class换成interface就行，注意的是，访问修饰符只能是public或default，接口中的属性只能是常量，总是以public static final修饰，不写默认也是如此。接口中的方法只能是public abstract，省略的话，默认也是如此。

子类可以通过implements来实现接口中的规范。接口不能创建对象，实现了接口的类必须实现接口中的所有方法，并且这些方法只能是public的。接口中不能有普通属性、构造方法、普通方法，只能是静态常量、抽象方法。

虽然Java中类不能多继承，但接口完全支持多继承，和类继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。

> - 普通类：具体实现;
> - 抽象类：具体实现、规范;
> - 接口：规范。

例如：完成接口的定义、继承、实现实验。

```java
public class Demo12 {
	public static void main(String[] args) {
		Test t = new Test();
		t.testA();		// print: I am testA!
		t.testB();		// print: I am testB!
		t.testC();		// print: I am testC!
	}
}

interface A{
	public void testA();
}

interface B{
	public void testB();
}

interface C extends A,B{
	public void testC();
}

class Test implements C{

	@Override
	public void testA() {
		System.out.println("I am testA!");
	}

	@Override
	public void testB() {
		System.out.println("I am testB!");
	}

	@Override
	public void testC() {
		System.out.println("I am testC!");
	}
}
```

## 五、枚举

枚举类型：

- 只能取特定值中的一个。
- 使用enum关键字。
- 所有的枚举类型隐性地继承自java.lang.Enum。枚举实质上还是类，而每个
  被枚举的成员实质就是一个枚举类型的实例。
- 强烈建议当你需要定义一组常量时，使用枚举类型。

例如：创建一个四季枚举。

```java
public class Demo13 {
	public static void main(String[] args) {
		Season s1 = Season.春;
		Season s2 = Season.values()[1];
		System.out.println(s1+","+s2);		// print: 春,夏
	}
}

enum Season{
	春,夏,秋,冬
}
```
<!--Markdown从这里结束  -->
	</textarea>
    <div id="preview" class="container"></div>
    <script>
        $("#preview").html(marked($("#content").val()));
        $("table").addClass("table table-bordered table-striped");
    </script>
</body>

</html>