<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <script src="/js/markdown.js"></script>
    <script src="/js/jquery.min.js"></script>
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/content.css">
	<link rel="stylesheet" href="/css/prism.css">
	<title>处理异常</title>
</head>

<body>
    <textarea hidden id="content">
<!--Markdown从这里开始  -->
# 处理异常
---

## 一、异常是什么

在程序的设计中，遇到的情况不可能是非常完美的。比如：你想操作文件，这个文件可能不存在或者文件格式不对;你遍历一个数组，可能超出它的索引范围了;在进行数学计算的时候，除数为0等等，许多这种情况经常发生。在软件运行的过程中，遇到的这些情况把它们叫做异常。英文是Exception，意思是例外，它能让我们写的程序做出合理的处理，不至于程序崩溃。

例如：我们对数组的操作索引越界。

```java
public class Demo01 {
	public static void main(String[] args) {
		int[] a = {1,2,3,4,5};
		System.out.println(a[5]);
	}
}
```

这是控制台会输出：

```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
	at ajn.zhihu.zhuanlan.chapter12.Demo01.main(Demo01.java:6)
```

根据上面的输出信息，我们可以发现出现的异常类为java.lang.ArrayIndexOutOfBoundsException，出现异常的代码是在Demo01.java文件中的第6行。设计良好的程序应该在异常发生提供处理这些错误的方法，使程序不会因为异常的发生而终断或产生不可预见的结果。

## 二、异常的分类

JDK中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是继承于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。 ![0002](0002.png)

### 1. Error

Error类层次描述了Java运行时系统内部错误和资源耗尽错误。这类错误是我们无法控制的，同时也是非常罕见的错误，所以在编程中，不去处理这类错误，Error表明系统JVM已经处于不可恢复的崩溃状态中。

### 2. Exception

Exception是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。它可以分为两大类：

1.RuntimeException：出现了这类的异常就一定是自己的问题，可以不捕获，因为此类异常是可以避免的。这类特殊的异常产生比较频繁，处理麻烦，如果需要声明或捕获将会对程序可读性和运行效率影响很大。因此由系统自动检测并将它们交给缺省的异常处理程序（用户可不必对其处理）。这类异常通常是由编程错误导致的，只要小心点，这些异常都是可以避免的，所以在编常写程序时，并不要求必须使用异常处理机制来处理这类异常, 所有这类异常自都继承自 java.lang.RuntimeException。

常见的RuntimeException异常：

|            异常             |        描述         |
| :-----------------------: | :---------------: |
|    ArithmeticException    |  算术计算异常。比如：除数为0。  |
|   NullPointerException    | 访问一个空对象的成员变量或方法。  |
|    ClassCastException     | 类转换异常。比如：多态向下转型。  |
| IndexOutOfBoundsException |  访问的元素下标超过索引长度。   |
|   NumberFormatException   | 数字格式异常。比如：字符串转数字。 |

2.CheckedException：所有不是RuntimeException的异常，统称为CheckedException，又称为“已检查异常”。这类异常的产生不是程序本身的问题，通常由外界因素造成的。为了预防这些异常产生时，造成程序的中断或得到不正确的结果，Java 要求编写可能产生这类异常的程序代码时，一定要去做异常的处理。

例如：要打开的文件不存在。编译器将检查是否为所有已检查异常提供异常处理。这一类异常，我们必须捕获进行处理。

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

public class Demo02 {
	public static void main(String[] args) {
		try {
			InputStream is = new FileInputStream("readme.txt");
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
}
```

Java语言将派生于RuntimeException类或 Error类的所有异常称为“未检查异常”。

## 三、处理异常的方法

### 1. 捕获异常

捕获异常的基本过程：

```java
try{
	Expressions 1;
	Expressions 2;
}catch(Exception1 e){

}catch(Exception2 e){

}finally{

}
```

过程详解：

**try语句块**

try 语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。一个try语句必须带有至少一个catch语句块或个一个finally语句块。注：<u>当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码</u>。

**catch语句块**

- 每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。
- 常用方法：
  - toString( )方法，显示异常的类名和产生异常的原因。
  - getMessage( ) 方法，只显示产生异常的原因，但不显示类名。
  - printStackTrace( ) 方法，用来跟踪异常事件发生时堆栈的内容。
- catch捕获异常时的捕获顺序：如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面。再不然就直接把多余的catch省略掉，先抓小的，再抓大的。

**finally语句块**

有些语句不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。通常在finally中关闭程序块已打开的资源，比如：文件流、释放数据库连接等。

**try，catch，finally，return执行顺序**

```java
import java.io.FileInputStream;
import java.io.InputStream;

public class Demo02 {
	static int a = 1;
	public static void main(String[] args){
		InputStream is = null;
		try {
			System.out.println("try: "+(a++));
			is = new FileInputStream("readme.txt");
			return;
		} catch (Exception e) {
			System.out.println("catch: "+(a++));
			e.printStackTrace();
		}finally{
			System.out.println("finally: "+(a++));
		}
	}
}
```

输出如下：

```
try: 1
catch: 2
java.io.FileNotFoundException: readme.txt (系统找不到指定的文件。)
	at java.io.FileInputStream.open0(Native Method)
	at java.io.FileInputStream.open(Unknown Source)
	at java.io.FileInputStream.<init>(Unknown Source)
	at java.io.FileInputStream.<init>(Unknown Source)
	at ajn.zhihu.zhuanlan.chapter12.Demo02.main(Demo02.java:12)
finally: 3
```

分析：我们知道方法中有return的地方就会终止方法的运行，但是上面代码try语句中的return并没有提前执行，反而后面的catch和finally语句块中的语句先执行了，根据前面讲的，自己想想为什么。

### 2. 抛出异常

当CheckedException产生时，不一定立刻要处理它，可以把异常Throws出去。在方法中我们前面讲到了可以用try-catch-finally来处理异常，在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。

如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。

例如：读取文件的异常，这些代码我们并不需要了解，到后面我们会讲到，只需知道处理异常的方法。

```java
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Demo03 {
	public static void main(String[] args) {
		try {
			readFile("joke.txt");
		} catch (FileNotFoundException e) {
			System.out.println("所需文件不存在！");
		} catch (IOException e) {
			System.out.println("文件读写错误！");
		}
	}

	public static void readFile(String fileName) throws FileNotFoundException,IOException{
		FileReader in = new FileReader(fileName);
		int tem = 0;
		try {
			tem = in.read();
			while (tem != -1) {
				System.out.print((char) tem);
				tem = in.read();
			}
		} finally {
			in.close();
		}
	}
}
```

### 3. 声明异常

- Java 异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要手工创建并抛出。
- 在捕获一个异常前，必须有一段代码先生成异常对象并把它抛出。这个过程我们可以手工做，也可以由 JRE 来实现，但是他们调用的都是 throw 子句。
- 对于一个已经存在的异常类，抛出该类异常对象过程如下：
  - 找到一个合适的异常类。
  - 创建一个该类的对象。
  - 将对象抛出

```java
import java.io.File;
import java.io.FileNotFoundException;

public class Demo04 {
	public static void main(String[] args) {
		File f = new File("c:/tt.txt");
		if (!f.exists()) {
			try {
				throw new FileNotFoundException("File can't be found!");
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}
	}
}
```

输出结果：

```
java.io.FileNotFoundException: File can't be found!
	at ajn.zhihu.zhuanlan.chapter12.Demo04.main(Demo04.java:11)
```

## 四、自定义异常

- 在程序中，可能会遇到任何标准异常类都没有充分的描述清楚的问题，这种情况下可以创建自己的异常类。
- 从 Exception 类或者它的子类派生一个子类即可。
- 习惯上，定义的类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。

例如：创建一个判断年龄的范围的异常类，并使用它。

```java
public class AgeException extends Exception{

	public AgeException() {
		super();
	}

	public AgeException(String message) {
		super(message);
	}

}
```

```java
public class Person {
	private String name;
	private int age;

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void setAge(int age) throws AgeException {
		if(age<0 || age>120){
			throw new AgeException("设置年龄有误!");
		}else{
			this.age = age;
		}
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
}
```

```java
public class Demo05 {
	public static void main(String[] args) {
		Person p1 = new Person("Alice", 18);
		Person p2 = new Person("Bob", 20);
		try {
			p2.setAge(121);
		} catch (AgeException e) {
			e.printStackTrace();
		}
		System.out.println(p1.getAge());
		System.out.println(p2.getAge());
	}
}
```

输出结果：

```
ajn.zhihu.zhuanlan.chapter12.AgeException: 设置年龄有误!
	at ajn.zhihu.zhuanlan.chapter12.Person.setAge(Person.java:14)
	at ajn.zhihu.zhuanlan.chapter12.Demo05.main(Demo05.java:8)
18
20
```
<!--Markdown从这里结束  -->
	</textarea>
    <div id="preview" class="container"></div>
    <script>
        $("#preview").html(marked($("#content").val()));
        $("table").addClass("table table-bordered table-striped");
    </script>
    <script src="/js/prism.js"></script>
</body>

</html>