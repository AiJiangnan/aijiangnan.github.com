<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <script src="/js/markdown.js"></script>
    <script src="/js/jquery.min.js"></script>
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/content.css">
	<link rel="stylesheet" href="/css/prism.css">
	<title>JDBC实例之质数与合数操作</title>
</head>

<body>
    <textarea hidden id="content">
<!--Markdown从这里开始  -->
# JDBC实例之质数与合数操作
---

为了增加代码的重用性，在这个实例中，会把数据库一些常用的操作封装起来，制作一个数据库工具类。

## 一、创建数据表

```sql
CREATE TABLE t_number (
	nno VARCHAR2(32) PRIMARY KEY,
	nnum NUMBER(7) NOT NULL,
	ntype CHAR(2)
);
```

主键使用Java中随机生成的UUID。

## 二、创建JDBC工具类

将一些经常进行修改的配置保存在属性文件中，在src目录下面新建jdbc.properties文件如下：

```properties
## Oracle Driver
driver=oracle.jdbc.OracleDriver
## url
url=jdbc:oracle:thin:@localhost:1521:orcl
## user
user=ajn
## password
password=ajn
```

工具类代码：

```java
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/**
 * 数据库连接工具类
 */
public class DBUtil {
	private static String driver;
	private static String url;
	private static String user;
	private static String password;

	/**
	 * 通过静态代码块，保证配置文件只被读取一次即可
	 */
	static{
		Properties prop = new Properties();
		try {
			prop.load(DBUtil.class.getResourceAsStream("/jdbc.properties"));
			driver = prop.getProperty("driver");
			url = prop.getProperty("url");
			user = prop.getProperty("user");
			password = prop.getProperty("password");
			Class.forName(driver);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 获取数据库连接
	 * @return Connection
	 */
	public static Connection getConn() {
		Connection conn = null;
		try {
			conn = DriverManager.getConnection(url, user, password);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return conn;
	}
	/**
	 * 获取预处理发送器
	 * @param conn
	 * @param sql
	 * @return PreparedStatement
	 */
	public static PreparedStatement getPstmt(Connection conn,String sql) {
		PreparedStatement pstmt = null;
		try {
			pstmt = conn.prepareStatement(sql);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return pstmt;
	}
	/**
	 * 动态绑定参数
	 * @param pstmt
	 * @param args
	 */
	public static void bindParams(PreparedStatement pstmt,Object...args) {
		for (int i=0;i<args.length;i++){
			try {
				pstmt.setObject(i+1, args[i]);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
	/**
	 * 统一释放资源
	 * @param rs
	 * @param stmt
	 * @param conn
	 */
	public static void closeAll(ResultSet rs,Statement stmt,Connection conn) {
		try {
			if(rs!=null){
				rs.close();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		try {
			if(stmt!=null){
				stmt.close();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		try {
			if(conn!=null){
				conn.close();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}
```

分析：

- 使用静态代码块来加载只需执行一次的配置文件和数据库驱动。
- 使用预处理SQL语句发送器防止SQL注入。
- 使用可变参数来动态绑定参数，注意参数的输入顺序。

## 三、写入数据操作

**1. 为执行写入操作的准备工作**

创建数据库表的实体类：

```java
public class Num {
	private String nno;
	private int nnum;
	private String ntype;

	public String getNno() {
		return nno;
	}
	public void setNno(String nno) {
		this.nno = nno;
	}
	public int getNnum() {
		return nnum;
	}
	public void setNnum(int nnum) {
		this.nnum = nnum;
	}
	public String getNtype() {
		return ntype;
	}
	public void setNtype(String ntype) {
		this.ntype = ntype;
	}
}
```

创建UUID的方法：

```java
private static String getUUID() {
	return UUID.randomUUID().toString().replace("-", "");
}
```

判断是否为质数的方法：

```java
private static boolean isPrime(int n) {
	if(n<=3){
		return n>1;
	}
	for (int i=2;i<=Math.sqrt(n);i++) {
		if(n%i==0){
			return false;
		}
	}
	return true;
}
```

**2. 先插入100条数据，为插入100000条数据作准备**

插入数据的主方法：

```java
public static void main(String[] args) {
	int num = 100;
	long start = System.currentTimeMillis();
	for(int i=2;i<=num;i++){
		insertNum(i);
	}
	long end = System.currentTimeMillis();
	System.out.println("本次操作时间："+(end-start)+"ms");
}
```

执行插入数据的insertNum方法：

```java
private static void insertNum(int num) {
	String sql = "insert into t_number values(?,?,?)";
	Connection conn = DBUtil.getConn();
	PreparedStatement pstmt = DBUtil.getPstmt(conn, sql);
	try {
		DBUtil.bindParams(pstmt, getUUID(), num, isPrime(num)?"ZS":"HS");
		pstmt.executeUpdate();
	} catch (SQLException e) {
		e.printStackTrace();
	} finally {
		DBUtil.closeAll(null, pstmt, conn);
	}
}
```

分析：使用此方法只能插入较少的数据，速度慢，效率低，因为每执行一次循环都会连接一次数据库，所以可以对其进行优化，将连接数据库的操作放在循环外面，可以查看代码的执行速度来判断代码的效率。

**3. 优化后的代码插入100000条数据**

插入数据的主方法：

```java
public static void main(String[] args) {
	int num = 100000;
	long start = System.currentTimeMillis();
	insertNum2(num);
	long end = System.currentTimeMillis();
	System.out.println("本次操作时间："+(end-start)+"ms");
}
```

优化后的插入数据的insertNum2方法：

```java
private static void insertNum2(int num) {
	String sql = "insert into t_number values(?,?,?)";
	Connection conn = DBUtil.getConn();
	PreparedStatement pstmt = DBUtil.getPstmt(conn, sql);
	try {
		for(int i=2;i<=num;i++){
			DBUtil.bindParams(pstmt, getUUID(), i, isPrime(i)?"ZS":"HS");
			pstmt.executeUpdate();
		}
	} catch (SQLException e) {
		e.printStackTrace();
	} finally {
		DBUtil.closeAll(null, pstmt, conn);
	}
}
```

分析：这种方法虽然比第一次插入操作的速度快，但不是最好的，还可以进一步的代码，使用批处理来插入效率会更高。

**4. 使用批处理和手动提交事务来插入100000条数据**

插入数据的主方法：

```java
public static void main(String[] args) {
	int num = 100000;
	long start = System.currentTimeMillis();
	insertNumByBatch(num);
	long end = System.currentTimeMillis();
	System.out.println("本次操作时间："+(end-start)+"ms");
}
```

使用批处理和手动提交事务的insertNumByBatch方法：

```java
private static void insertNumByBatch(int num) {
	String sql = "insert into t_number values(?,?,?)";
	Connection conn = DBUtil.getConn();
	PreparedStatement pstmt = DBUtil.getPstmt(conn, sql);
	try {
		conn.setAutoCommit(false);
		for(int i=2;i<=num;i++){
			DBUtil.bindParams(pstmt, getUUID(), i, isPrime(i)?"ZS":"HS");
			pstmt.addBatch();
		}
		pstmt.executeBatch();
		conn.commit();
	} catch (SQLException e) {
		e.printStackTrace();
		try {
			conn.rollback();
		} catch (SQLException e1) {
			e1.printStackTrace();
		}
	} finally {
		DBUtil.closeAll(null, pstmt, conn);
	}
}
```

分析：这种方法能使大大地提升操作数据库的速度，执行插入100000条数据在几秒内即可完成，以后使用数据库连接池会更快。

## 四、查询操作实例

**1. 查询某个数是质数还是合数**

```java
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import com.ajn.jdbc.util.DBUtil;

public class TestNum1 {
	public static void main(String[] args) {
		int num = 567;
		String type = queryNumType(num);
		if(type!=null){
		System.out.println("数字["+num+"]是一个"+(type.equals("ZS")?"质数":"合数"));
		}else{
			System.out.println("没有"+num+"这个数。");
		}
	}

	private static String queryNumType(int num) {
		String sql = "SELECT ntype FROM t_number WHERE nnum=?";
		Connection conn = DBUtil.getConn();
		PreparedStatement pstmt = DBUtil.getPstmt(conn, sql);
		ResultSet rs = null;
		DBUtil.bindParams(pstmt, num);
		try {
			rs = pstmt.executeQuery();
			if(rs.next()){
				return rs.getString(1);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DBUtil.closeAll(rs, pstmt, conn);
		}
		return null;
	}
}
```

**2. 查询2~100000中质数与合数的个数**

```java
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import com.ajn.jdbc.util.DBUtil;

public class TestNum2 {
	public static void main(String[] args) {
		Map<String,Integer> map = queryNumByType();
		if(map!=null){
			Set<String> types = map.keySet();
			for (String type : types) {
				System.out.println("["+(type.equals("ZS")?"质数":"合数")+"]有"+map.get(type)+"个");
			}
		}else{
			System.out.println("没有数据！");
		}
	}

	private static Map<String, Integer> queryNumByType() {
		Map<String, Integer> map = new HashMap<String, Integer>();
		String sql = "SELECT ntype,COUNT(*) FROM t_number GROUP BY ntype";
		Connection conn = DBUtil.getConn();
		PreparedStatement pstmt = DBUtil.getPstmt(conn, sql);
		ResultSet rs = null;
		try {
			rs = pstmt.executeQuery();
			while(rs.next()){
				map.put(rs.getString(1), rs.getInt(2));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DBUtil.closeAll(rs, pstmt, conn);
		}
		return map.size()>0?map:null;
	}
}
```

## 五、数据库到XML的备份与还原

**1. 将数据库数据备份到XML文件中**

```java
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.XMLWriter;

import com.ajn.jdbc.util.DBUtil;

public class TestNum3 {
	public static void main(String[] args) {
		String path = System.getProperty("user.dir")+File.separator+"src"+File.separator+"num.xml";
		List<Num> list = queryAllNum();
		writeNumToXML(list,path);
	}

	private static void writeNumToXML(List<Num> list, String path) {
		Document doc = DocumentHelper.createDocument();
		Element root = doc.addElement("numbers");
		for(int i=0;i<list.size();i++){
			Num num = list.get(i);
			Element number = root.addElement("number");
			number.addAttribute("nno", num.getNno());
			number.addAttribute("ntype", num.getNtype());
			number.addText(num.getNnum()+"");
		}
		OutputFormat format = OutputFormat.createPrettyPrint();
		XMLWriter xw = null;
		try {
			xw = new XMLWriter(new FileWriter(path),format);
			xw.write(doc);
		} catch (IOException e) {
			e.printStackTrace();
		} finally{
			if(xw!=null){
				try {
					xw.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}

	private static List<Num> queryAllNum() {
		List<Num> list = new ArrayList<Num>();
		String sql = "SELECT * FROM t_number ORDER BY nnum";
		Connection conn = DBUtil.getConn();
		PreparedStatement pstmt = DBUtil.getPstmt(conn, sql);
		ResultSet rs = null;
		try {
			rs = pstmt.executeQuery();
			while(rs.next()){
				Num num = new Num();
				num.setNno(rs.getString("nno"));
				num.setNnum(rs.getInt("nnum"));
				num.setNtype(rs.getString("ntype"));
				list.add(num);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DBUtil.closeAll(rs, pstmt, conn);
		}
		return list.size()>0?list:null;
	}
}
```

分析：使用dom4j的jar包来对SML文件的读取与写入。

**2. 将XML文件中数据还原到数据库**

```java
import java.io.File;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import com.ajn.jdbc.util.DBUtil;

public class TestNum4 {
	public static void main(String[] args) {
		String path = System.getProperty("user.dir")+File.separator+"src"+File.separator+"num.xml";
		List<Num> list = readNumToList(path);
		System.out.println(list.size());
		insertNumFromList(list);
	}

	private static void insertNumFromList(List<Num> list) {
		String sql = "insert into t_number values(?,?,?)";
		Connection conn = DBUtil.getConn();
		PreparedStatement pstmt = DBUtil.getPstmt(conn, sql);
		try {
			conn.setAutoCommit(false);
			for(int i=0;i<list.size();i++){
				Num num = list.get(i);
				DBUtil.bindParams(pstmt, num.getNno(), num.getNnum(), num.getNtype());
				pstmt.addBatch();
			}
			pstmt.executeBatch();
			conn.commit();
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			DBUtil.closeAll(null, pstmt, conn);
		}
	}

	private static List<Num> readNumToList(String path) {
		List<Num> list = new ArrayList<Num>();
		SAXReader reader = new SAXReader();
		try {
			Document doc = reader.read(new File(path));
			Element root = doc.getRootElement();
			Iterator<?> it = root.elementIterator();
			while(it.hasNext()){
				Element e = (Element) it.next();
				Num num = new Num();
				num.setNno(e.attributeValue("nno"));
				num.setNnum(Integer.parseInt(e.getText()));
				num.setNtype(e.attributeValue("ntype"));
				list.add(num);
			}
		} catch (DocumentException e) {
			e.printStackTrace();
		}
		return list.size()>0?list:null;
	}
}
```

<!--Markdown从这里结束  -->
	</textarea>
    <div id="preview" class="container"></div>
    <script>
        $("#preview").html(marked($("#content").val()));
        $("table").addClass("table table-bordered table-striped");
    </script>
    <script src="/js/prism.js"></script>
</body>

</html>