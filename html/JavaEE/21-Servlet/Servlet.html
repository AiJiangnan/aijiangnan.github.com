<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <script src="/js/markdown.js"></script>
    <script src="/js/jquery.min.js"></script>
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/content.css">
    <link rel="stylesheet" href="/css/prism.css">
    <title>Java EE Servlet</title>
</head>

<body>
    <textarea hidden id="content">
<!--Markdown从这里开始  -->
# Java EE Servlet

## 一、HTTP

1. 超文本传输协议，用于规范资源在网络中传输的标准。
2. 请求部分
   - 请求行：请求方式 资源路径 协议版本号
   - 请求头：表示客户端告知服务器端的一些信息
     - User-agent：表示客户端浏览器的类型。
     - Referer：表示从哪个url进入到当前页面的。
   - 响应部分
     - 响应行：协议版本号 状态码 描述信息
       - 1xx：表示消息。
       - 2xx：表示成功，200。
       - 3xx：表示重定向，302，304。
       - 4xx：表示请求错误（客户端问题），404，403。
       - 5xx：表示服务器端错误，500。
     - 响应头：表示服务器告知浏览器的一些信息
       - Location：表示重定向时应该跳转的路径。
       - Content-Type：用于指定浏览器要以何种方式展示响应内容（其中可以设置字符集）。
     - 响应实体：就是响应的具体内容，一般就是页面的源代码

## 二、Servlet

- 全称Server Applet，服务器端小程序。是一个运行在服务器端的java程序，用于接收客户端的请求，并对请求做出响应。
- 单例多线程，Servlet是多线程的，有一个客户端就创建一个线程;默认是懒汉式单例，即第一次请求的时候，加载Servlet（实例化和初始化），只加载一遍;可以通过load-on-startup配置servlet为饿汉式单例，即项目被加载的时候就会加载Servlet。
- Servlet的生命周期：
  1. 载入（载入到虚拟机并实例化）：只一次;
  2. 初始化：调用init方法，只一次;
  3. 执行：每次请求都会调用service方法;
  4. 销毁：在servlet被销毁前，会调用destroy方法。
- Servlet（接口）->GenericServlet（抽象类）->HttpServlet（抽象类）。

### 1. HttpServletRequest

- 接口：继承了ServletRequest接口。
- 由Servlet容器创建的一个对象，之后会传递到servlet的service方法中作为参数，用于为提供客户端的请求信息。
- 请求行：
  - `getMethod()`
  - `getRequestURI()`
  - `getRequestURL()`
  - `getQueryString()`
  - `getProtocol()`
  - `getSchema()`
- 请求头：
  - `getHeader()`
  - `getHeaderNames()`
- 请求实体：
  - `getParameter()`
  - `getParameterValues()`

### 2. HttpServletResponse

- 接口：继承了ServletResponse接口。
- 它由Servlet容器创建，传给Servlet的service方法作为参数，用于帮助Servlet对客户端的请求做出响应。
- 响应头：
  - `setHeader()`
  - `addHeader()`
- 响应体：
  - `resp.getWriter().print()`
  - `setContentType()`

### 3. ServletConfig

- 接口：用于在Servlet初始化的时候向Servlet提供参数。
- 参数要定义在web.xml的servlet标签下。
- 获取参数：`config.getInitParameter()`。
- 获取Servlet的名字：`config.getServletName()`。

### 4. ServletContext

- 接口：一个web应用只有一个ServletContext对象，用于表示整个应用，被所有servlet共享，也被称之为application。
- 获取全局配置信息。
- 获取路径：`getContextPath(),getRealPath()`。
- 获取WebRoot下的文件资源：`getResourceAsStream()`。
- 可以进行请求转发。

### 5. HttpSession

- 会话，接口，它提供了一种在跨多个页面时标识用户的方式，还可以用于存储用户的信息，存储在服务器端。
- 生命周期：
  - 创建：第一次请求的时候就会创建
  - 销毁：
    - 客户端丢失JSessionId：关闭浏览器
    - 服务器关闭
    - session过期：默认是30分钟，在tomcat的web.xml中可以配置，在本项目中的web.xml中也可以修改，还可以通过`setMaxInactiveInterval(seconds)`设置。
    - `session.invalidate()`
- session的跟踪机制：通过cookie画存储JSessionId。

### 6. Cookie

- 类，用于存储少量信息的一个对象，在服务器端创建，发送到客户端浏览器保存，之后的访问中，浏览器会自动携带cookie信息。
- `Cookie cookie = new Cookie(name,value);`
- `resp.addCookie(cookie);`
- cookie默认存储在浏览器内存中，可以通过设置最大寿命（`setMaxAge(seconds)`）之后，cookie会存储到客户端本地磁盘。
- `setMaxAge(0)`会将cookie删除。
- cookie默认是所有访问路径都会被携带，可以通过设置访问路径（`setPath(path)`）之后，cookie只有在访问指定路径时才会被携带。

### 7. 请求转发和重定向

1. 请求转发
   - `req.getRequestDispathcher(path).forward(req,resp) `
   - 只发送一次请求
   - 地址栏路径不变
   - 参数可以继续传递
   - 只能访问内部资源
2. 重定向
   - `resp.sendRedirect(location)`
   - 会发两次请求
   - 地址栏路径改变
   - 参数不能继续传递
   - 可以访问外部资源

### 8. 乱码问题

1. 页面乱码解决

   - `<meta http-equiv="Content-Type" content="text/html;charset="UTF-8">`

2. 后台乱码解决

   - 请求乱码：

     - Post：`req.setCharacterEncoding("UTF-8")`

     - Get：

       - 先用iso-8859-1解码为字节数组，再用UTF-8编码为字符串

       - 可以配置tomcat的server.xml：

         `URIEncoding="UTF-8",useBodyEncodingForURI="true"`

   - 响应乱码：

     - `resp.setCharacterEncoding="UTF-8"`
     - `resp.setHeader("Cotent-Type","text/html;charset=UTF-8")`
     - `resp.setContentType("text/html;charset=UTF-8")`

### 9. 路径问题

1. 根路径

   - 项目根路径：/bjsxt
   - 服务器根路径：/

2. 相对路径

   相对于当前路径查找资源，当资源据当前路径较远时，路径会写的很复杂，容易出错，后续维护超麻烦。

3. 绝对路径

   从盘符直接定位资源，在请求转发中，“/”表示项目根路径，在重定向中，“/”表示服务器根路径。

### 10. Servlet的三大作用域

方法：`setAttribute(),getAttribute(),removeAttribute()`

1. request->HttpServletRequest
   - 生命周期：一次请求
   - 作用范围：请求转发涉及的Sevlet
2. session->HttpSession
   - 生命周期：一次会话
   - 作用范围：会话中的所有Servlet
3. application->ServletContext
   - 生命周期：项目的加载到卸载
   - 作用范围：所有的Servlet

## 三、JSP

- 全称：Java Server Page
- JSP也是Servlet
- xxx.jsp->web.xml->JspServlet->xxx_jsp.java->xxx_jsp.class->_jspService()->浏览器显示
- 即可以写html代码，也可以写java代码（`<% %>,<%= %>,<%! %>`），但是尽量不要在JSP中写java代码
- MVC（JavaBean，JSP，Servlet）
- 指令：
  - 编译器指令：`page,taglib,include`
  - 动作指令：`<jsp:include>,<jsp:forward>,<jsp:import>,<jsp:useBean>,<jsp:param>,<jsp:setProperty>,<jsp:getProterty>`

### 1. JSP的九大内置对象

1. pageContext,request,session,application
2. response,out
3. config,page,exception

### 2. EL表达式

1. 全称：Excepression Language
2. 使用方式：`${ }`
3. 用于获取提交的数据：`${param.xxx}, ${paramValues.xxx}`
4. 用于获取作用域中的数据：`${xxx}`
5. 运算符：`empty,eq,neq,...`

### 3. JSTL

1. Jsp Stantard Tag Library

2. 先要使用`<%@taglib uri="" prefix=""%>`引入标签库才能使用

3. 核心标签库：

   - `core: <%@taglib uri="http://java.sum.com/jsp/jstl/core" prefix="c"%>`


   - `set,out,remove,if,choose,when,otherwise,forEach`

4. 格式化标签库：

   - `format: <%@taglib uri="http://java.sum.com/jsp/jstl/fmt" prefix="fmt"%>`


   - `formatDate,formatNum,parseDate,parseNum`

5. 函数标签库：

   - `functions: <%@taglib uri="http://java.sum.com/jsp/jstl/functions" prefix="fn"%>`


   - `${fn:length(str)},trim(),contains(),join(),...`

6. 自定义标签库

   - 在WEB-INF下创建tld文件
   - 定义java类
     - 自定义函数标签库：普通类，有公开的静态方法
     - 自定义标签：要继承TagSupport类，重写对应方法
   - 根据类和方法信息配置tld文件
   - 使用方式和默认jstl方式一样

### 4. 过滤器

1. Filter接口，有三个方法：`init(),destroy(),doFilter()`
2. 作用是在访问对应资源前，先执行过滤器，然后再继续访问
3. 一定要先在web.xml中配置好过滤器才能使用
4. 过滤器的执行顺序和`<filter-mapping>`的顺序相关
5. 解决中文乱码，解决登录判断

### 5. 监听器

1. 有8个接口
2. 功能是用于监听作用域的变化
3. request有两个，application有两个，session有四个
4. 记录请求信息，设置basePath，监听在线人数（session）
5. 过滤器要配置在Servlet前，listener后。
<!--Markdown从这里结束  -->
</textarea>
  <div id="preview" class="container"></div>
  <script>
      $("#preview").html(marked($("#content").val()));
      $("table").addClass("table table-bordered table-striped");
  </script>
  <script src="/js/prism.js"></script>
</body>

</html>