<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <script src="/js/markdown.js"></script>
    <script src="/js/jquery.min.js"></script>
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/content.css">
    <link rel="stylesheet" href="/css/prism.css">
    <title>ROWID和ROWNUM</title>
</head>

<body>
    <textarea hidden id="content">
<!--Markdown从这里开始  -->
# ROWID和ROWNUM
---

## 一、ROWID和ROWNUM的特点

**ROWID**

- ROWID在记录创建时生成，而且是不变，直接指向硬件上的存储位置
- 用ROWID直接访问是最快的，但也是人力所无法做到的
- 只要记录没被搬动过，ROWID是不变的

**ROWNUM**

- ROWNUM是个伪列，查询的时候除非特别指定，否则不会显示
- 其主要的用处是控制查询返回的行数
- 只能使用：<、<=
- 当ROWNUM和ORDER BY一起使用时，会首先选出符合ROWNUM条件的记录，然后再进行排序，这会给我们的查询带来难度

## 二、ROWNUM操作

一般不对ROWID进行操作，ROWNUM相当于行号，可以根据排序来获取排名。例如：查询工资最高的前五名：

```sql
-- 查询所有工资排序
SELECT * FROM emp ORDER BY sal DESC;
-- 错误查询
SELECT * FROM emp WHERE ROWNUM<=5 ORDER BY sal DESC;
-- 正确查询
SELECT * FROM (
       SELECT * FROM emp ORDER BY sal DESC
) t WHERE ROWNUM<=5;
```

分析：为什么要使用子查询才能获取前五？根据SQL语句执行顺序思考。

## 三、使用ROWNUM分页查询

```sql
-- 第一页
SELECT * FROM (
	SELECT ROWNUM rn,t.* FROM (
		SELECT * FROM emp ORDER BY sal DESC
	) t WHERE ROWNUM<=5
) m WHERE m.rn>0;
-- 第二页
SELECT * FROM (
	SELECT ROWNUM rn,t.* FROM (
		SELECT * FROM emp ORDER BY sal DESC
	) t WHERE ROWNUM<=10
) m WHERE m.rn>5;
-- 第三页
SELECT * FROM (
	SELECT ROWNUM rn,t.* FROM (
		SELECT * FROM emp ORDER BY sal DESC
	) t WHERE ROWNUM<=15
) m WHERE m.rn>10;
-- 第page页，假设每页显示size条数据
SELECT * FROM (
	SELECT ROWNUM rn,t.* FROM (
		SELECT * FROM emp ORDER BY sal DESC
	) t WHERE ROWNUM<=(size*page)
) m WHERE m.rn>(size*(page-1));
```

分析：因为使用ROWNUM不能使用大于号，所以需要利用子查询来进行分页的范围取值。

<!--Markdown从这里结束  -->
	</textarea>
    <div id="preview" class="container"></div>
    <script>
        $("#preview").html(marked($("#content").val()));
        $("table").addClass("table table-bordered table-striped");
    </script>
    <script src="/js/prism.js"></script>
</body>

</html>